/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "protocol_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_ProtocolDataType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_DATA_TYPE_BOOL:return "PROTOCOL_DATA_TYPE_BOOL";
  case PROTOCOL_DATA_TYPE_UINT_8:return "PROTOCOL_DATA_TYPE_UINT_8";
  case PROTOCOL_DATA_TYPE_UINT_16:return "PROTOCOL_DATA_TYPE_UINT_16";
  case PROTOCOL_DATA_TYPE_UINT_32:return "PROTOCOL_DATA_TYPE_UINT_32";
  case PROTOCOL_DATA_TYPE_INT_32:return "PROTOCOL_DATA_TYPE_INT_32";
  case PROTOCOL_DATA_TYPE_FLOAT:return "PROTOCOL_DATA_TYPE_FLOAT";
  case PROTOCOL_DATA_TYPE_STRING:return "PROTOCOL_DATA_TYPE_STRING";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolConstantType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_CONSTANT_TYPE_BOOL:return "PROTOCOL_CONSTANT_TYPE_BOOL";
  case PROTOCOL_CONSTANT_TYPE_INTEGER:return "PROTOCOL_CONSTANT_TYPE_INTEGER";
  case PROTOCOL_CONSTANT_TYPE_FLOAT:return "PROTOCOL_CONSTANT_TYPE_FLOAT";
  case PROTOCOL_CONSTANT_TYPE_STRING:return "PROTOCOL_CONSTANT_TYPE_STRING";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolExpressionNodeType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_EXPRESSION_NODE_TYPE_OPERAND:return "PROTOCOL_EXPRESSION_NODE_TYPE_OPERAND";
  case PROTOCOL_EXPRESSION_NODE_TYPE_OPERATOR:return "PROTOCOL_EXPRESSION_NODE_TYPE_OPERATOR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolExpressionOperandType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_EXPRESSION_OPERAND_TYPE_CONSTANT:return "PROTOCOL_EXPRESSION_OPERAND_TYPE_CONSTANT";
  case PROTOCOL_EXPRESSION_OPERAND_TYPE_COLUMN_PTR:return "PROTOCOL_EXPRESSION_OPERAND_TYPE_COLUMN_PTR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolOperatorType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_OPERATOR_TYPE_NOT:return "PROTOCOL_OPERATOR_TYPE_NOT";
  case PROTOCOL_OPERATOR_TYPE_AND:return "PROTOCOL_OPERATOR_TYPE_AND";
  case PROTOCOL_OPERATOR_TYPE_OR:return "PROTOCOL_OPERATOR_TYPE_OR";
  case PROTOCOL_OPERATOR_TYPE_EQUAL:return "PROTOCOL_OPERATOR_TYPE_EQUAL";
  case PROTOCOL_OPERATOR_TYPE_NOT_EQUAL:return "PROTOCOL_OPERATOR_TYPE_NOT_EQUAL";
  case PROTOCOL_OPERATOR_TYPE_LESS:return "PROTOCOL_OPERATOR_TYPE_LESS";
  case PROTOCOL_OPERATOR_TYPE_NOT_LESS:return "PROTOCOL_OPERATOR_TYPE_NOT_LESS";
  case PROTOCOL_OPERATOR_TYPE_GREATER:return "PROTOCOL_OPERATOR_TYPE_GREATER";
  case PROTOCOL_OPERATOR_TYPE_NOT_GREATER:return "PROTOCOL_OPERATOR_TYPE_NOT_GREATER";
  case PROTOCOL_OPERATOR_TYPE_SUBSTR:return "PROTOCOL_OPERATOR_TYPE_SUBSTR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolDataSourceNodeType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_DATA_SOURCE_NODE_TYPE_TABLE:return "PROTOCOL_DATA_SOURCE_NODE_TYPE_TABLE";
  case PROTOCOL_DATA_SOURCE_NODE_TYPE_EXPRESSION:return "PROTOCOL_DATA_SOURCE_NODE_TYPE_EXPRESSION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolQueryType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_QUERY_TYPE_SELECT:return "PROTOCOL_QUERY_TYPE_SELECT";
  case PROTOCOL_QUERY_TYPE_DELETE:return "PROTOCOL_QUERY_TYPE_DELETE";
  case PROTOCOL_QUERY_TYPE_INSERT:return "PROTOCOL_QUERY_TYPE_INSERT";
  case PROTOCOL_QUERY_TYPE_UPDATE:return "PROTOCOL_QUERY_TYPE_UPDATE";
  case PROTOCOL_QUERY_TYPE_CREATE_TABLE:return "PROTOCOL_QUERY_TYPE_CREATE_TABLE";
  case PROTOCOL_QUERY_TYPE_DELETE_TABLE:return "PROTOCOL_QUERY_TYPE_DELETE_TABLE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ProtocolQueryResultCode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_QUERY_RESULT_CODE_OK:return "PROTOCOL_QUERY_RESULT_CODE_OK";
  case PROTOCOL_QUERY_RESULT_CODE_ERROR:return "PROTOCOL_QUERY_RESULT_CODE_ERROR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _ProtocolConstantUnionProperties
{
  PROP_PROTOCOL_CONSTANT_UNION_0,
  PROP_PROTOCOL_CONSTANT_UNION_BOOL_CONSTANT,
  PROP_PROTOCOL_CONSTANT_UNION_INTEGER_CONSTANT,
  PROP_PROTOCOL_CONSTANT_UNION_FLOAT_CONSTANT,
  PROP_PROTOCOL_CONSTANT_UNION_STRING_CONSTANT
};

/* reads a protocol_constant_union object */
static gint32
protocol_constant_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolConstantUnion * this_object = PROTOCOL_CONSTANT_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->bool_constant, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bool_constant = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->integer_constant, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer_constant = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->float_constant, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_float_constant = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->string_constant != NULL)
          {
            g_free(this_object->string_constant);
            this_object->string_constant = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->string_constant, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_string_constant = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_constant_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolConstantUnion * this_object = PROTOCOL_CONSTANT_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolConstantUnion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_bool_constant == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bool_constant", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->bool_constant, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_integer_constant == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "integer_constant", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->integer_constant, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_float_constant == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "float_constant", T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->float_constant, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_string_constant == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "string_constant", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->string_constant, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_constant_union_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ProtocolConstantUnion *self = PROTOCOL_CONSTANT_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CONSTANT_UNION_BOOL_CONSTANT:
      self->bool_constant = g_value_get_boolean (value);
      self->__isset_bool_constant = TRUE;
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_INTEGER_CONSTANT:
      self->integer_constant = g_value_get_int (value);
      self->__isset_integer_constant = TRUE;
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_FLOAT_CONSTANT:
      self->float_constant = g_value_get_double (value);
      self->__isset_float_constant = TRUE;
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_STRING_CONSTANT:
      if (self->string_constant != NULL)
        g_free (self->string_constant);
      self->string_constant = g_value_dup_string (value);
      self->__isset_string_constant = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_constant_union_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ProtocolConstantUnion *self = PROTOCOL_CONSTANT_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CONSTANT_UNION_BOOL_CONSTANT:
      g_value_set_boolean (value, self->bool_constant);
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_INTEGER_CONSTANT:
      g_value_set_int (value, self->integer_constant);
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_FLOAT_CONSTANT:
      g_value_set_double (value, self->float_constant);
      break;

    case PROP_PROTOCOL_CONSTANT_UNION_STRING_CONSTANT:
      g_value_set_string (value, self->string_constant);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_constant_union_instance_init (ProtocolConstantUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bool_constant = 0;
  object->__isset_bool_constant = FALSE;
  object->integer_constant = 0;
  object->__isset_integer_constant = FALSE;
  object->float_constant = 0;
  object->__isset_float_constant = FALSE;
  object->string_constant = NULL;
  object->__isset_string_constant = FALSE;
}

static void 
protocol_constant_union_finalize (GObject *object)
{
  ProtocolConstantUnion *tobject = PROTOCOL_CONSTANT_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->string_constant != NULL)
  {
    g_free(tobject->string_constant);
    tobject->string_constant = NULL;
  }
}

static void
protocol_constant_union_class_init (ProtocolConstantUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_constant_union_read;
  struct_class->write = protocol_constant_union_write;

  gobject_class->finalize = protocol_constant_union_finalize;
  gobject_class->get_property = protocol_constant_union_get_property;
  gobject_class->set_property = protocol_constant_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_UNION_BOOL_CONSTANT,
     g_param_spec_boolean ("bool_constant",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_UNION_INTEGER_CONSTANT,
     g_param_spec_int ("integer_constant",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_UNION_FLOAT_CONSTANT,
     g_param_spec_double ("float_constant",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_UNION_STRING_CONSTANT,
     g_param_spec_string ("string_constant",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
protocol_constant_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolConstantUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_constant_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolConstantUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_constant_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolConstantUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolConstantProperties
{
  PROP_PROTOCOL_CONSTANT_0,
  PROP_PROTOCOL_CONSTANT_TYPE,
  PROP_PROTOCOL_CONSTANT_VALUE
};

/* reads a protocol_constant object */
static gint32
protocol_constant_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolConstant * this_object = PROTOCOL_CONSTANT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolConstantType)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_constant_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolConstant * this_object = PROTOCOL_CONSTANT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolConstant", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_constant_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  ProtocolConstant *self = PROTOCOL_CONSTANT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CONSTANT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_CONSTANT_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_constant_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  ProtocolConstant *self = PROTOCOL_CONSTANT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CONSTANT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_CONSTANT_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_constant_instance_init (ProtocolConstant * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_PROTOCOL_CONSTANT_UNION, NULL);
  object->__isset_value = FALSE;
}

static void 
protocol_constant_finalize (GObject *object)
{
  ProtocolConstant *tobject = PROTOCOL_CONSTANT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
protocol_constant_class_init (ProtocolConstantClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_constant_read;
  struct_class->write = protocol_constant_write;

  gobject_class->finalize = protocol_constant_finalize;
  gobject_class->get_property = protocol_constant_get_property;
  gobject_class->set_property = protocol_constant_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CONSTANT_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_CONSTANT_UNION,
                         G_PARAM_READWRITE));
}

GType
protocol_constant_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolConstantClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_constant_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolConstant),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_constant_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolConstantType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolVariableProperties
{
  PROP_PROTOCOL_VARIABLE_0,
  PROP_PROTOCOL_VARIABLE_NAME
};

/* reads a protocol_variable object */
static gint32
protocol_variable_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolVariable * this_object = PROTOCOL_VARIABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_variable_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolVariable * this_object = PROTOCOL_VARIABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolVariable", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_variable_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  ProtocolVariable *self = PROTOCOL_VARIABLE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_VARIABLE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_variable_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  ProtocolVariable *self = PROTOCOL_VARIABLE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_VARIABLE_NAME:
      g_value_set_string (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_variable_instance_init (ProtocolVariable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
}

static void 
protocol_variable_finalize (GObject *object)
{
  ProtocolVariable *tobject = PROTOCOL_VARIABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
protocol_variable_class_init (ProtocolVariableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_variable_read;
  struct_class->write = protocol_variable_write;

  gobject_class->finalize = protocol_variable_finalize;
  gobject_class->get_property = protocol_variable_get_property;
  gobject_class->set_property = protocol_variable_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_VARIABLE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
protocol_variable_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolVariableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_variable_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolVariable),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_variable_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolVariableType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolColumnPtrProperties
{
  PROP_PROTOCOL_COLUMN_PTR_0,
  PROP_PROTOCOL_COLUMN_PTR_TABLE_NAME,
  PROP_PROTOCOL_COLUMN_PTR_COLUMN_NAME
};

/* reads a protocol_column_ptr object */
static gint32
protocol_column_ptr_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolColumnPtr * this_object = PROTOCOL_COLUMN_PTR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_column_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_column_ptr_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolColumnPtr * this_object = PROTOCOL_COLUMN_PTR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolColumnPtr", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_name", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_column_ptr_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolColumnPtr *self = PROTOCOL_COLUMN_PTR (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_COLUMN_PTR_TABLE_NAME:
      if (self->table_name != NULL)
        g_object_unref (self->table_name);
      self->table_name = g_value_dup_object (value);
      self->__isset_table_name = TRUE;
      break;

    case PROP_PROTOCOL_COLUMN_PTR_COLUMN_NAME:
      if (self->column_name != NULL)
        g_object_unref (self->column_name);
      self->column_name = g_value_dup_object (value);
      self->__isset_column_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_column_ptr_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolColumnPtr *self = PROTOCOL_COLUMN_PTR (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_COLUMN_PTR_TABLE_NAME:
      g_value_set_object (value, self->table_name);
      break;

    case PROP_PROTOCOL_COLUMN_PTR_COLUMN_NAME:
      g_value_set_object (value, self->column_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_column_ptr_instance_init (ProtocolColumnPtr * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_table_name = FALSE;
  object->column_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_column_name = FALSE;
}

static void 
protocol_column_ptr_finalize (GObject *object)
{
  ProtocolColumnPtr *tobject = PROTOCOL_COLUMN_PTR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_object_unref(tobject->table_name);
    tobject->table_name = NULL;
  }
  if (tobject->column_name != NULL)
  {
    g_object_unref(tobject->column_name);
    tobject->column_name = NULL;
  }
}

static void
protocol_column_ptr_class_init (ProtocolColumnPtrClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_column_ptr_read;
  struct_class->write = protocol_column_ptr_write;

  gobject_class->finalize = protocol_column_ptr_finalize;
  gobject_class->get_property = protocol_column_ptr_get_property;
  gobject_class->set_property = protocol_column_ptr_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_COLUMN_PTR_TABLE_NAME,
     g_param_spec_object ("table_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_COLUMN_PTR_COLUMN_NAME,
     g_param_spec_object ("column_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));
}

GType
protocol_column_ptr_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolColumnPtrClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_column_ptr_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolColumnPtr),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_column_ptr_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolColumnPtrType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolProjectionProperties
{
  PROP_PROTOCOL_PROJECTION_0,
  PROP_PROTOCOL_PROJECTION_COLUMN_PTRS
};

/* reads a protocol_projection object */
static gint32
protocol_projection_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolProjection * this_object = PROTOCOL_PROJECTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolColumnPtr * _elem1 = NULL;
              if ( _elem1 != NULL)
              {
                g_object_unref (_elem1);
              }
              _elem1 = g_object_new (TYPE_PROTOCOL_COLUMN_PTR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
              {
                g_object_unref (_elem1);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->column_ptrs, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_column_ptrs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_projection_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolProjection * this_object = PROTOCOL_PROJECTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolProjection", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_ptrs", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i2;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->column_ptrs ? this_object->column_ptrs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i2 = 0; i2 < (this_object->column_ptrs ? this_object->column_ptrs->len : 0); i2++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->column_ptrs, i2))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_projection_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolProjection *self = PROTOCOL_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_PROJECTION_COLUMN_PTRS:
      if (self->column_ptrs != NULL)
        g_ptr_array_unref (self->column_ptrs);
      self->column_ptrs = g_value_dup_boxed (value);
      self->__isset_column_ptrs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_projection_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolProjection *self = PROTOCOL_PROJECTION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_PROJECTION_COLUMN_PTRS:
      g_value_set_boxed (value, self->column_ptrs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_projection_instance_init (ProtocolProjection * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_ptrs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_column_ptrs = FALSE;
}

static void 
protocol_projection_finalize (GObject *object)
{
  ProtocolProjection *tobject = PROTOCOL_PROJECTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column_ptrs != NULL)
  {
    g_ptr_array_unref (tobject->column_ptrs);
    tobject->column_ptrs = NULL;
  }
}

static void
protocol_projection_class_init (ProtocolProjectionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_projection_read;
  struct_class->write = protocol_projection_write;

  gobject_class->finalize = protocol_projection_finalize;
  gobject_class->get_property = protocol_projection_get_property;
  gobject_class->set_property = protocol_projection_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_PROJECTION_COLUMN_PTRS,
     g_param_spec_boxed ("column_ptrs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_projection_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolProjectionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_projection_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolProjection),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_projection_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolProjectionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionOperandUnionProperties
{
  PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_0,
  PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_CONSTANT_OPERAND,
  PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_COLUMN_PTR_OPERAND
};

/* reads a protocol_expression_operand_union object */
static gint32
protocol_expression_operand_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpressionOperandUnion * this_object = PROTOCOL_EXPRESSION_OPERAND_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->constant_operand), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_constant_operand = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column_ptr_operand), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_column_ptr_operand = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_operand_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpressionOperandUnion * this_object = PROTOCOL_EXPRESSION_OPERAND_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpressionOperandUnion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_constant_operand == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "constant_operand", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->constant_operand), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_ptr_operand == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_ptr_operand", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column_ptr_operand), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_operand_union_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ProtocolExpressionOperandUnion *self = PROTOCOL_EXPRESSION_OPERAND_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_CONSTANT_OPERAND:
      if (self->constant_operand != NULL)
        g_object_unref (self->constant_operand);
      self->constant_operand = g_value_dup_object (value);
      self->__isset_constant_operand = TRUE;
      break;

    case PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_COLUMN_PTR_OPERAND:
      if (self->column_ptr_operand != NULL)
        g_object_unref (self->column_ptr_operand);
      self->column_ptr_operand = g_value_dup_object (value);
      self->__isset_column_ptr_operand = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_operand_union_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ProtocolExpressionOperandUnion *self = PROTOCOL_EXPRESSION_OPERAND_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_CONSTANT_OPERAND:
      g_value_set_object (value, self->constant_operand);
      break;

    case PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_COLUMN_PTR_OPERAND:
      g_value_set_object (value, self->column_ptr_operand);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_operand_union_instance_init (ProtocolExpressionOperandUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->constant_operand = g_object_new (TYPE_PROTOCOL_CONSTANT, NULL);
  object->__isset_constant_operand = FALSE;
  object->column_ptr_operand = g_object_new (TYPE_PROTOCOL_COLUMN_PTR, NULL);
  object->__isset_column_ptr_operand = FALSE;
}

static void 
protocol_expression_operand_union_finalize (GObject *object)
{
  ProtocolExpressionOperandUnion *tobject = PROTOCOL_EXPRESSION_OPERAND_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->constant_operand != NULL)
  {
    g_object_unref(tobject->constant_operand);
    tobject->constant_operand = NULL;
  }
  if (tobject->column_ptr_operand != NULL)
  {
    g_object_unref(tobject->column_ptr_operand);
    tobject->column_ptr_operand = NULL;
  }
}

static void
protocol_expression_operand_union_class_init (ProtocolExpressionOperandUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_operand_union_read;
  struct_class->write = protocol_expression_operand_union_write;

  gobject_class->finalize = protocol_expression_operand_union_finalize;
  gobject_class->get_property = protocol_expression_operand_union_get_property;
  gobject_class->set_property = protocol_expression_operand_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_CONSTANT_OPERAND,
     g_param_spec_object ("constant_operand",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_CONSTANT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_OPERAND_UNION_COLUMN_PTR_OPERAND,
     g_param_spec_object ("column_ptr_operand",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_COLUMN_PTR,
                         G_PARAM_READWRITE));
}

GType
protocol_expression_operand_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionOperandUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_operand_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpressionOperandUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_operand_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionOperandUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionOperandProperties
{
  PROP_PROTOCOL_EXPRESSION_OPERAND_0,
  PROP_PROTOCOL_EXPRESSION_OPERAND_TYPE,
  PROP_PROTOCOL_EXPRESSION_OPERAND_OPERAND
};

/* reads a protocol_expression_operand object */
static gint32
protocol_expression_operand_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpressionOperand * this_object = PROTOCOL_EXPRESSION_OPERAND(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast3;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolExpressionOperandType)ecast3;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->operand), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_operand = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_operand_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpressionOperand * this_object = PROTOCOL_EXPRESSION_OPERAND(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpressionOperand", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "operand", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->operand), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_operand_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolExpressionOperand *self = PROTOCOL_EXPRESSION_OPERAND (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERAND_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_EXPRESSION_OPERAND_OPERAND:
      if (self->operand != NULL)
        g_object_unref (self->operand);
      self->operand = g_value_dup_object (value);
      self->__isset_operand = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_operand_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolExpressionOperand *self = PROTOCOL_EXPRESSION_OPERAND (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERAND_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_EXPRESSION_OPERAND_OPERAND:
      g_value_set_object (value, self->operand);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_operand_instance_init (ProtocolExpressionOperand * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->operand = g_object_new (TYPE_PROTOCOL_EXPRESSION_OPERAND_UNION, NULL);
  object->__isset_operand = FALSE;
}

static void 
protocol_expression_operand_finalize (GObject *object)
{
  ProtocolExpressionOperand *tobject = PROTOCOL_EXPRESSION_OPERAND (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->operand != NULL)
  {
    g_object_unref(tobject->operand);
    tobject->operand = NULL;
  }
}

static void
protocol_expression_operand_class_init (ProtocolExpressionOperandClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_operand_read;
  struct_class->write = protocol_expression_operand_write;

  gobject_class->finalize = protocol_expression_operand_finalize;
  gobject_class->get_property = protocol_expression_operand_get_property;
  gobject_class->set_property = protocol_expression_operand_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_OPERAND_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_OPERAND_OPERAND,
     g_param_spec_object ("operand",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION_OPERAND_UNION,
                         G_PARAM_READWRITE));
}

GType
protocol_expression_operand_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionOperandClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_operand_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpressionOperand),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_operand_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionOperandType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionOperatorProperties
{
  PROP_PROTOCOL_EXPRESSION_OPERATOR_0,
  PROP_PROTOCOL_EXPRESSION_OPERATOR_TYPE
};

/* reads a protocol_expression_operator object */
static gint32
protocol_expression_operator_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpressionOperator * this_object = PROTOCOL_EXPRESSION_OPERATOR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast4;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolOperatorType)ecast4;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_operator_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpressionOperator * this_object = PROTOCOL_EXPRESSION_OPERATOR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpressionOperator", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_operator_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ProtocolExpressionOperator *self = PROTOCOL_EXPRESSION_OPERATOR (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERATOR_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_operator_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ProtocolExpressionOperator *self = PROTOCOL_EXPRESSION_OPERATOR (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_OPERATOR_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_operator_instance_init (ProtocolExpressionOperator * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
}

static void 
protocol_expression_operator_finalize (GObject *object)
{
  ProtocolExpressionOperator *tobject = PROTOCOL_EXPRESSION_OPERATOR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
protocol_expression_operator_class_init (ProtocolExpressionOperatorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_operator_read;
  struct_class->write = protocol_expression_operator_write;

  gobject_class->finalize = protocol_expression_operator_finalize;
  gobject_class->get_property = protocol_expression_operator_get_property;
  gobject_class->set_property = protocol_expression_operator_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_OPERATOR_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       10,
                       1,
                       G_PARAM_READWRITE));
}

GType
protocol_expression_operator_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionOperatorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_operator_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpressionOperator),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_operator_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionOperatorType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionNodeUnionProperties
{
  PROP_PROTOCOL_EXPRESSION_NODE_UNION_0,
  PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERAND,
  PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERATOR
};

/* reads a protocol_expression_node_union object */
static gint32
protocol_expression_node_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpressionNodeUnion * this_object = PROTOCOL_EXPRESSION_NODE_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->operand), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_operand = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->operator), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_operator = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_node_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpressionNodeUnion * this_object = PROTOCOL_EXPRESSION_NODE_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpressionNodeUnion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_operand == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "operand", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->operand), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_operator == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "operator", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->operator), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_node_union_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  ProtocolExpressionNodeUnion *self = PROTOCOL_EXPRESSION_NODE_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERAND:
      if (self->operand != NULL)
        g_object_unref (self->operand);
      self->operand = g_value_dup_object (value);
      self->__isset_operand = TRUE;
      break;

    case PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERATOR:
      if (self->operator != NULL)
        g_object_unref (self->operator);
      self->operator = g_value_dup_object (value);
      self->__isset_operator = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_node_union_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  ProtocolExpressionNodeUnion *self = PROTOCOL_EXPRESSION_NODE_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERAND:
      g_value_set_object (value, self->operand);
      break;

    case PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERATOR:
      g_value_set_object (value, self->operator);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_node_union_instance_init (ProtocolExpressionNodeUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->operand = g_object_new (TYPE_PROTOCOL_EXPRESSION_OPERAND, NULL);
  object->__isset_operand = FALSE;
  object->operator = g_object_new (TYPE_PROTOCOL_EXPRESSION_OPERATOR, NULL);
  object->__isset_operator = FALSE;
}

static void 
protocol_expression_node_union_finalize (GObject *object)
{
  ProtocolExpressionNodeUnion *tobject = PROTOCOL_EXPRESSION_NODE_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->operand != NULL)
  {
    g_object_unref(tobject->operand);
    tobject->operand = NULL;
  }
  if (tobject->operator != NULL)
  {
    g_object_unref(tobject->operator);
    tobject->operator = NULL;
  }
}

static void
protocol_expression_node_union_class_init (ProtocolExpressionNodeUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_node_union_read;
  struct_class->write = protocol_expression_node_union_write;

  gobject_class->finalize = protocol_expression_node_union_finalize;
  gobject_class->get_property = protocol_expression_node_union_get_property;
  gobject_class->set_property = protocol_expression_node_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERAND,
     g_param_spec_object ("operand",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION_OPERAND,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_NODE_UNION_OPERATOR,
     g_param_spec_object ("operator",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION_OPERATOR,
                         G_PARAM_READWRITE));
}

GType
protocol_expression_node_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionNodeUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_node_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpressionNodeUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_node_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionNodeUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionNodeProperties
{
  PROP_PROTOCOL_EXPRESSION_NODE_0,
  PROP_PROTOCOL_EXPRESSION_NODE_TYPE,
  PROP_PROTOCOL_EXPRESSION_NODE_VALUE
};

/* reads a protocol_expression_node object */
static gint32
protocol_expression_node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpressionNode * this_object = PROTOCOL_EXPRESSION_NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast5;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolExpressionNodeType)ecast5;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpressionNode * this_object = PROTOCOL_EXPRESSION_NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpressionNode", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_node_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ProtocolExpressionNode *self = PROTOCOL_EXPRESSION_NODE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_NODE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_EXPRESSION_NODE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_node_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ProtocolExpressionNode *self = PROTOCOL_EXPRESSION_NODE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_NODE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_EXPRESSION_NODE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_node_instance_init (ProtocolExpressionNode * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_PROTOCOL_EXPRESSION_NODE_UNION, NULL);
  object->__isset_value = FALSE;
}

static void 
protocol_expression_node_finalize (GObject *object)
{
  ProtocolExpressionNode *tobject = PROTOCOL_EXPRESSION_NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
protocol_expression_node_class_init (ProtocolExpressionNodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_node_read;
  struct_class->write = protocol_expression_node_write;

  gobject_class->finalize = protocol_expression_node_finalize;
  gobject_class->get_property = protocol_expression_node_get_property;
  gobject_class->set_property = protocol_expression_node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_NODE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_NODE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION_NODE_UNION,
                         G_PARAM_READWRITE));
}

GType
protocol_expression_node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionNodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpressionNode),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionNodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolExpressionProperties
{
  PROP_PROTOCOL_EXPRESSION_0,
  PROP_PROTOCOL_EXPRESSION_LIST
};

/* reads a protocol_expression object */
static gint32
protocol_expression_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolExpression * this_object = PROTOCOL_EXPRESSION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolExpressionNode * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (TYPE_PROTOCOL_EXPRESSION_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->list, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_expression_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolExpression * this_object = PROTOCOL_EXPRESSION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolExpression", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->list ? this_object->list->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < (this_object->list ? this_object->list->len : 0); i7++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->list, i7))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_expression_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolExpression *self = PROTOCOL_EXPRESSION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_LIST:
      if (self->list != NULL)
        g_ptr_array_unref (self->list);
      self->list = g_value_dup_boxed (value);
      self->__isset_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_expression_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolExpression *self = PROTOCOL_EXPRESSION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_EXPRESSION_LIST:
      g_value_set_boxed (value, self->list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_expression_instance_init (ProtocolExpression * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_list = FALSE;
}

static void 
protocol_expression_finalize (GObject *object)
{
  ProtocolExpression *tobject = PROTOCOL_EXPRESSION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->list != NULL)
  {
    g_ptr_array_unref (tobject->list);
    tobject->list = NULL;
  }
}

static void
protocol_expression_class_init (ProtocolExpressionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_expression_read;
  struct_class->write = protocol_expression_write;

  gobject_class->finalize = protocol_expression_finalize;
  gobject_class->get_property = protocol_expression_get_property;
  gobject_class->set_property = protocol_expression_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_EXPRESSION_LIST,
     g_param_spec_boxed ("list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_expression_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolExpressionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_expression_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolExpression),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_expression_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolExpressionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDataSourceTableProperties
{
  PROP_PROTOCOL_DATA_SOURCE_TABLE_0,
  PROP_PROTOCOL_DATA_SOURCE_TABLE_TABLE_NAME,
  PROP_PROTOCOL_DATA_SOURCE_TABLE_VARIABLE_NAME
};

/* reads a protocol_data_source_table object */
static gint32
protocol_data_source_table_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDataSourceTable * this_object = PROTOCOL_DATA_SOURCE_TABLE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->variable_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_variable_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_data_source_table_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDataSourceTable * this_object = PROTOCOL_DATA_SOURCE_TABLE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDataSourceTable", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "variable_name", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->variable_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_data_source_table_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ProtocolDataSourceTable *self = PROTOCOL_DATA_SOURCE_TABLE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_TABLE_TABLE_NAME:
      if (self->table_name != NULL)
        g_object_unref (self->table_name);
      self->table_name = g_value_dup_object (value);
      self->__isset_table_name = TRUE;
      break;

    case PROP_PROTOCOL_DATA_SOURCE_TABLE_VARIABLE_NAME:
      if (self->variable_name != NULL)
        g_object_unref (self->variable_name);
      self->variable_name = g_value_dup_object (value);
      self->__isset_variable_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_data_source_table_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ProtocolDataSourceTable *self = PROTOCOL_DATA_SOURCE_TABLE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_TABLE_TABLE_NAME:
      g_value_set_object (value, self->table_name);
      break;

    case PROP_PROTOCOL_DATA_SOURCE_TABLE_VARIABLE_NAME:
      g_value_set_object (value, self->variable_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_data_source_table_instance_init (ProtocolDataSourceTable * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_table_name = FALSE;
  object->variable_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_variable_name = FALSE;
}

static void 
protocol_data_source_table_finalize (GObject *object)
{
  ProtocolDataSourceTable *tobject = PROTOCOL_DATA_SOURCE_TABLE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_object_unref(tobject->table_name);
    tobject->table_name = NULL;
  }
  if (tobject->variable_name != NULL)
  {
    g_object_unref(tobject->variable_name);
    tobject->variable_name = NULL;
  }
}

static void
protocol_data_source_table_class_init (ProtocolDataSourceTableClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_data_source_table_read;
  struct_class->write = protocol_data_source_table_write;

  gobject_class->finalize = protocol_data_source_table_finalize;
  gobject_class->get_property = protocol_data_source_table_get_property;
  gobject_class->set_property = protocol_data_source_table_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_TABLE_TABLE_NAME,
     g_param_spec_object ("table_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_TABLE_VARIABLE_NAME,
     g_param_spec_object ("variable_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));
}

GType
protocol_data_source_table_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDataSourceTableClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_data_source_table_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDataSourceTable),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_data_source_table_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDataSourceTableType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDataSourceUnionProperties
{
  PROP_PROTOCOL_DATA_SOURCE_UNION_0,
  PROP_PROTOCOL_DATA_SOURCE_UNION_TABLE,
  PROP_PROTOCOL_DATA_SOURCE_UNION_EXPRESSION
};

/* reads a protocol_data_source_union object */
static gint32
protocol_data_source_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDataSourceUnion * this_object = PROTOCOL_DATA_SOURCE_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->expression), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_expression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_data_source_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDataSourceUnion * this_object = PROTOCOL_DATA_SOURCE_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDataSourceUnion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_table == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expression == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expression", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->expression), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_data_source_union_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ProtocolDataSourceUnion *self = PROTOCOL_DATA_SOURCE_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_UNION_TABLE:
      if (self->table != NULL)
        g_object_unref (self->table);
      self->table = g_value_dup_object (value);
      self->__isset_table = TRUE;
      break;

    case PROP_PROTOCOL_DATA_SOURCE_UNION_EXPRESSION:
      if (self->expression != NULL)
        g_object_unref (self->expression);
      self->expression = g_value_dup_object (value);
      self->__isset_expression = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_data_source_union_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ProtocolDataSourceUnion *self = PROTOCOL_DATA_SOURCE_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_UNION_TABLE:
      g_value_set_object (value, self->table);
      break;

    case PROP_PROTOCOL_DATA_SOURCE_UNION_EXPRESSION:
      g_value_set_object (value, self->expression);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_data_source_union_instance_init (ProtocolDataSourceUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table = g_object_new (TYPE_PROTOCOL_DATA_SOURCE_TABLE, NULL);
  object->__isset_table = FALSE;
  object->expression = g_object_new (TYPE_PROTOCOL_EXPRESSION, NULL);
  object->__isset_expression = FALSE;
}

static void 
protocol_data_source_union_finalize (GObject *object)
{
  ProtocolDataSourceUnion *tobject = PROTOCOL_DATA_SOURCE_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table != NULL)
  {
    g_object_unref(tobject->table);
    tobject->table = NULL;
  }
  if (tobject->expression != NULL)
  {
    g_object_unref(tobject->expression);
    tobject->expression = NULL;
  }
}

static void
protocol_data_source_union_class_init (ProtocolDataSourceUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_data_source_union_read;
  struct_class->write = protocol_data_source_union_write;

  gobject_class->finalize = protocol_data_source_union_finalize;
  gobject_class->get_property = protocol_data_source_union_get_property;
  gobject_class->set_property = protocol_data_source_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_UNION_TABLE,
     g_param_spec_object ("table",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DATA_SOURCE_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_UNION_EXPRESSION,
     g_param_spec_object ("expression",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION,
                         G_PARAM_READWRITE));
}

GType
protocol_data_source_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDataSourceUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_data_source_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDataSourceUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_data_source_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDataSourceUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDataSourceNodeProperties
{
  PROP_PROTOCOL_DATA_SOURCE_NODE_0,
  PROP_PROTOCOL_DATA_SOURCE_NODE_TYPE,
  PROP_PROTOCOL_DATA_SOURCE_NODE_VALUE
};

/* reads a protocol_data_source_node object */
static gint32
protocol_data_source_node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDataSourceNode * this_object = PROTOCOL_DATA_SOURCE_NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolDataSourceNodeType)ecast8;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_data_source_node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDataSourceNode * this_object = PROTOCOL_DATA_SOURCE_NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDataSourceNode", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_data_source_node_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ProtocolDataSourceNode *self = PROTOCOL_DATA_SOURCE_NODE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_NODE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_DATA_SOURCE_NODE_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_data_source_node_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ProtocolDataSourceNode *self = PROTOCOL_DATA_SOURCE_NODE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_NODE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_DATA_SOURCE_NODE_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_data_source_node_instance_init (ProtocolDataSourceNode * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_PROTOCOL_DATA_SOURCE_UNION, NULL);
  object->__isset_value = FALSE;
}

static void 
protocol_data_source_node_finalize (GObject *object)
{
  ProtocolDataSourceNode *tobject = PROTOCOL_DATA_SOURCE_NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
protocol_data_source_node_class_init (ProtocolDataSourceNodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_data_source_node_read;
  struct_class->write = protocol_data_source_node_write;

  gobject_class->finalize = protocol_data_source_node_finalize;
  gobject_class->get_property = protocol_data_source_node_get_property;
  gobject_class->set_property = protocol_data_source_node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_NODE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_NODE_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DATA_SOURCE_UNION,
                         G_PARAM_READWRITE));
}

GType
protocol_data_source_node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDataSourceNodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_data_source_node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDataSourceNode),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_data_source_node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDataSourceNodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDataSourceProperties
{
  PROP_PROTOCOL_DATA_SOURCE_0,
  PROP_PROTOCOL_DATA_SOURCE_LIST
};

/* reads a protocol_data_source object */
static gint32
protocol_data_source_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDataSource * this_object = PROTOCOL_DATA_SOURCE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolDataSourceNode * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_PROTOCOL_DATA_SOURCE_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->list, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_data_source_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDataSource * this_object = PROTOCOL_DATA_SOURCE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDataSource", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i10;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->list ? this_object->list->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i10 = 0; i10 < (this_object->list ? this_object->list->len : 0); i10++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->list, i10))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_data_source_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ProtocolDataSource *self = PROTOCOL_DATA_SOURCE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_LIST:
      if (self->list != NULL)
        g_ptr_array_unref (self->list);
      self->list = g_value_dup_boxed (value);
      self->__isset_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_data_source_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ProtocolDataSource *self = PROTOCOL_DATA_SOURCE (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DATA_SOURCE_LIST:
      g_value_set_boxed (value, self->list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_data_source_instance_init (ProtocolDataSource * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_list = FALSE;
}

static void 
protocol_data_source_finalize (GObject *object)
{
  ProtocolDataSource *tobject = PROTOCOL_DATA_SOURCE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->list != NULL)
  {
    g_ptr_array_unref (tobject->list);
    tobject->list = NULL;
  }
}

static void
protocol_data_source_class_init (ProtocolDataSourceClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_data_source_read;
  struct_class->write = protocol_data_source_write;

  gobject_class->finalize = protocol_data_source_finalize;
  gobject_class->get_property = protocol_data_source_get_property;
  gobject_class->set_property = protocol_data_source_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DATA_SOURCE_LIST,
     g_param_spec_boxed ("list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_data_source_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDataSourceClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_data_source_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDataSource),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_data_source_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDataSourceType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolAssignmentProperties
{
  PROP_PROTOCOL_ASSIGNMENT_0,
  PROP_PROTOCOL_ASSIGNMENT_TO,
  PROP_PROTOCOL_ASSIGNMENT_WHAT
};

/* reads a protocol_assignment object */
static gint32
protocol_assignment_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolAssignment * this_object = PROTOCOL_ASSIGNMENT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->to), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_to = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->what), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_what = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_assignment_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolAssignment * this_object = PROTOCOL_ASSIGNMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolAssignment", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "to", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->to), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "what", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->what), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_assignment_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolAssignment *self = PROTOCOL_ASSIGNMENT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_ASSIGNMENT_TO:
      if (self->to != NULL)
        g_object_unref (self->to);
      self->to = g_value_dup_object (value);
      self->__isset_to = TRUE;
      break;

    case PROP_PROTOCOL_ASSIGNMENT_WHAT:
      if (self->what != NULL)
        g_object_unref (self->what);
      self->what = g_value_dup_object (value);
      self->__isset_what = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_assignment_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolAssignment *self = PROTOCOL_ASSIGNMENT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_ASSIGNMENT_TO:
      g_value_set_object (value, self->to);
      break;

    case PROP_PROTOCOL_ASSIGNMENT_WHAT:
      g_value_set_object (value, self->what);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_assignment_instance_init (ProtocolAssignment * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->to = g_object_new (TYPE_PROTOCOL_COLUMN_PTR, NULL);
  object->__isset_to = FALSE;
  object->what = g_object_new (TYPE_PROTOCOL_EXPRESSION_OPERAND, NULL);
  object->__isset_what = FALSE;
}

static void 
protocol_assignment_finalize (GObject *object)
{
  ProtocolAssignment *tobject = PROTOCOL_ASSIGNMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->to != NULL)
  {
    g_object_unref(tobject->to);
    tobject->to = NULL;
  }
  if (tobject->what != NULL)
  {
    g_object_unref(tobject->what);
    tobject->what = NULL;
  }
}

static void
protocol_assignment_class_init (ProtocolAssignmentClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_assignment_read;
  struct_class->write = protocol_assignment_write;

  gobject_class->finalize = protocol_assignment_finalize;
  gobject_class->get_property = protocol_assignment_get_property;
  gobject_class->set_property = protocol_assignment_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_ASSIGNMENT_TO,
     g_param_spec_object ("to",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_COLUMN_PTR,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_ASSIGNMENT_WHAT,
     g_param_spec_object ("what",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION_OPERAND,
                         G_PARAM_READWRITE));
}

GType
protocol_assignment_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolAssignmentClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_assignment_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolAssignment),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_assignment_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolAssignmentType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolFilterProperties
{
  PROP_PROTOCOL_FILTER_0,
  PROP_PROTOCOL_FILTER_EXPRESSION
};

/* reads a protocol_filter object */
static gint32
protocol_filter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolFilter * this_object = PROTOCOL_FILTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->expression), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_expression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_filter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolFilter * this_object = PROTOCOL_FILTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolFilter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expression", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->expression), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_filter_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  ProtocolFilter *self = PROTOCOL_FILTER (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_FILTER_EXPRESSION:
      if (self->expression != NULL)
        g_object_unref (self->expression);
      self->expression = g_value_dup_object (value);
      self->__isset_expression = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_filter_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  ProtocolFilter *self = PROTOCOL_FILTER (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_FILTER_EXPRESSION:
      g_value_set_object (value, self->expression);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_filter_instance_init (ProtocolFilter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->expression = g_object_new (TYPE_PROTOCOL_EXPRESSION, NULL);
  object->__isset_expression = FALSE;
}

static void 
protocol_filter_finalize (GObject *object)
{
  ProtocolFilter *tobject = PROTOCOL_FILTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->expression != NULL)
  {
    g_object_unref(tobject->expression);
    tobject->expression = NULL;
  }
}

static void
protocol_filter_class_init (ProtocolFilterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_filter_read;
  struct_class->write = protocol_filter_write;

  gobject_class->finalize = protocol_filter_finalize;
  gobject_class->get_property = protocol_filter_get_property;
  gobject_class->set_property = protocol_filter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_FILTER_EXPRESSION,
     g_param_spec_object ("expression",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_EXPRESSION,
                         G_PARAM_READWRITE));
}

GType
protocol_filter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolFilterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_filter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolFilter),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_filter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolFilterType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolColumnDefProperties
{
  PROP_PROTOCOL_COLUMN_DEF_0,
  PROP_PROTOCOL_COLUMN_DEF_TYPE,
  PROP_PROTOCOL_COLUMN_DEF_NAME
};

/* reads a protocol_column_def object */
static gint32
protocol_column_def_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolColumnDef * this_object = PROTOCOL_COLUMN_DEF(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast11;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolDataType)ecast11;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_column_def_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolColumnDef * this_object = PROTOCOL_COLUMN_DEF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolColumnDef", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_column_def_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolColumnDef *self = PROTOCOL_COLUMN_DEF (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_COLUMN_DEF_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_COLUMN_DEF_NAME:
      if (self->name != NULL)
        g_object_unref (self->name);
      self->name = g_value_dup_object (value);
      self->__isset_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_column_def_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ProtocolColumnDef *self = PROTOCOL_COLUMN_DEF (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_COLUMN_DEF_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_COLUMN_DEF_NAME:
      g_value_set_object (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_column_def_instance_init (ProtocolColumnDef * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_name = FALSE;
}

static void 
protocol_column_def_finalize (GObject *object)
{
  ProtocolColumnDef *tobject = PROTOCOL_COLUMN_DEF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_object_unref(tobject->name);
    tobject->name = NULL;
  }
}

static void
protocol_column_def_class_init (ProtocolColumnDefClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_column_def_read;
  struct_class->write = protocol_column_def_write;

  gobject_class->finalize = protocol_column_def_finalize;
  gobject_class->get_property = protocol_column_def_get_property;
  gobject_class->set_property = protocol_column_def_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_COLUMN_DEF_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       7,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_COLUMN_DEF_NAME,
     g_param_spec_object ("name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));
}

GType
protocol_column_def_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolColumnDefClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_column_def_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolColumnDef),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_column_def_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolColumnDefType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolSelectQueryProperties
{
  PROP_PROTOCOL_SELECT_QUERY_0,
  PROP_PROTOCOL_SELECT_QUERY_DATA_SOURCE,
  PROP_PROTOCOL_SELECT_QUERY_FILTER,
  PROP_PROTOCOL_SELECT_QUERY_PROJECTION
};

/* reads a protocol_select_query object */
static gint32
protocol_select_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolSelectQuery * this_object = PROTOCOL_SELECT_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_source = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_projection = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_select_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolSelectQuery * this_object = PROTOCOL_SELECT_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolSelectQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_source", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_projection == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "projection", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->projection), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_select_query_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolSelectQuery *self = PROTOCOL_SELECT_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_SELECT_QUERY_DATA_SOURCE:
      if (self->data_source != NULL)
        g_object_unref (self->data_source);
      self->data_source = g_value_dup_object (value);
      self->__isset_data_source = TRUE;
      break;

    case PROP_PROTOCOL_SELECT_QUERY_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_PROTOCOL_SELECT_QUERY_PROJECTION:
      if (self->projection != NULL)
        g_object_unref (self->projection);
      self->projection = g_value_dup_object (value);
      self->__isset_projection = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_select_query_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolSelectQuery *self = PROTOCOL_SELECT_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_SELECT_QUERY_DATA_SOURCE:
      g_value_set_object (value, self->data_source);
      break;

    case PROP_PROTOCOL_SELECT_QUERY_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_PROTOCOL_SELECT_QUERY_PROJECTION:
      g_value_set_object (value, self->projection);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_select_query_instance_init (ProtocolSelectQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data_source = g_object_new (TYPE_PROTOCOL_DATA_SOURCE, NULL);
  object->__isset_data_source = FALSE;
  object->filter = g_object_new (TYPE_PROTOCOL_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->projection = g_object_new (TYPE_PROTOCOL_PROJECTION, NULL);
  object->__isset_projection = FALSE;
}

static void 
protocol_select_query_finalize (GObject *object)
{
  ProtocolSelectQuery *tobject = PROTOCOL_SELECT_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data_source != NULL)
  {
    g_object_unref(tobject->data_source);
    tobject->data_source = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
  if (tobject->projection != NULL)
  {
    g_object_unref(tobject->projection);
    tobject->projection = NULL;
  }
}

static void
protocol_select_query_class_init (ProtocolSelectQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_select_query_read;
  struct_class->write = protocol_select_query_write;

  gobject_class->finalize = protocol_select_query_finalize;
  gobject_class->get_property = protocol_select_query_get_property;
  gobject_class->set_property = protocol_select_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_SELECT_QUERY_DATA_SOURCE,
     g_param_spec_object ("data_source",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DATA_SOURCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_SELECT_QUERY_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_SELECT_QUERY_PROJECTION,
     g_param_spec_object ("projection",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_PROJECTION,
                         G_PARAM_READWRITE));
}

GType
protocol_select_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolSelectQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_select_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolSelectQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_select_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolSelectQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDeleteQueryProperties
{
  PROP_PROTOCOL_DELETE_QUERY_0,
  PROP_PROTOCOL_DELETE_QUERY_DATA_SOURCE,
  PROP_PROTOCOL_DELETE_QUERY_FILTER
};

/* reads a protocol_delete_query object */
static gint32
protocol_delete_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDeleteQuery * this_object = PROTOCOL_DELETE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_source = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_delete_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDeleteQuery * this_object = PROTOCOL_DELETE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDeleteQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_source", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_delete_query_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolDeleteQuery *self = PROTOCOL_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DELETE_QUERY_DATA_SOURCE:
      if (self->data_source != NULL)
        g_object_unref (self->data_source);
      self->data_source = g_value_dup_object (value);
      self->__isset_data_source = TRUE;
      break;

    case PROP_PROTOCOL_DELETE_QUERY_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_delete_query_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolDeleteQuery *self = PROTOCOL_DELETE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DELETE_QUERY_DATA_SOURCE:
      g_value_set_object (value, self->data_source);
      break;

    case PROP_PROTOCOL_DELETE_QUERY_FILTER:
      g_value_set_object (value, self->filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_delete_query_instance_init (ProtocolDeleteQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data_source = g_object_new (TYPE_PROTOCOL_DATA_SOURCE, NULL);
  object->__isset_data_source = FALSE;
  object->filter = g_object_new (TYPE_PROTOCOL_FILTER, NULL);
  object->__isset_filter = FALSE;
}

static void 
protocol_delete_query_finalize (GObject *object)
{
  ProtocolDeleteQuery *tobject = PROTOCOL_DELETE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data_source != NULL)
  {
    g_object_unref(tobject->data_source);
    tobject->data_source = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
protocol_delete_query_class_init (ProtocolDeleteQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_delete_query_read;
  struct_class->write = protocol_delete_query_write;

  gobject_class->finalize = protocol_delete_query_finalize;
  gobject_class->get_property = protocol_delete_query_get_property;
  gobject_class->set_property = protocol_delete_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DELETE_QUERY_DATA_SOURCE,
     g_param_spec_object ("data_source",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DATA_SOURCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DELETE_QUERY_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_FILTER,
                         G_PARAM_READWRITE));
}

GType
protocol_delete_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDeleteQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_delete_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDeleteQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_delete_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDeleteQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolInsertQueryProperties
{
  PROP_PROTOCOL_INSERT_QUERY_0,
  PROP_PROTOCOL_INSERT_QUERY_TABLE_NAME,
  PROP_PROTOCOL_INSERT_QUERY_DATA
};

/* reads a protocol_insert_query object */
static gint32
protocol_insert_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolInsertQuery * this_object = PROTOCOL_INSERT_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem12 = g_ptr_array_new_with_free_func (g_object_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  ProtocolConstant * _elem13 = NULL;
                  if ( _elem13 != NULL)
                  {
                    g_object_unref (_elem13);
                  }
                  _elem13 = g_object_new (TYPE_PROTOCOL_CONSTANT, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem13), protocol, error)) < 0)
                  {
                    g_object_unref (_elem13);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (_elem12, _elem13);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->data, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_insert_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolInsertQuery * this_object = PROTOCOL_INSERT_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolInsertQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) (this_object->data ? this_object->data->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->data ? this_object->data->len : 0); i14++)
    {
      {
        guint i15;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i14)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i14))->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i15 = 0; i15 < (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i14)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i14))->len : 0); i15++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i14)), i15))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_insert_query_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolInsertQuery *self = PROTOCOL_INSERT_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_INSERT_QUERY_TABLE_NAME:
      if (self->table_name != NULL)
        g_object_unref (self->table_name);
      self->table_name = g_value_dup_object (value);
      self->__isset_table_name = TRUE;
      break;

    case PROP_PROTOCOL_INSERT_QUERY_DATA:
      if (self->data != NULL)
        g_ptr_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_insert_query_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolInsertQuery *self = PROTOCOL_INSERT_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_INSERT_QUERY_TABLE_NAME:
      g_value_set_object (value, self->table_name);
      break;

    case PROP_PROTOCOL_INSERT_QUERY_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_insert_query_instance_init (ProtocolInsertQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_table_name = FALSE;
  object->data = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_data = FALSE;
}

static void 
protocol_insert_query_finalize (GObject *object)
{
  ProtocolInsertQuery *tobject = PROTOCOL_INSERT_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_object_unref(tobject->table_name);
    tobject->table_name = NULL;
  }
  if (tobject->data != NULL)
  {
    g_ptr_array_unref (tobject->data);
    tobject->data = NULL;
  }
}

static void
protocol_insert_query_class_init (ProtocolInsertQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_insert_query_read;
  struct_class->write = protocol_insert_query_write;

  gobject_class->finalize = protocol_insert_query_finalize;
  gobject_class->get_property = protocol_insert_query_get_property;
  gobject_class->set_property = protocol_insert_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_INSERT_QUERY_TABLE_NAME,
     g_param_spec_object ("table_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_INSERT_QUERY_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_insert_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolInsertQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_insert_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolInsertQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_insert_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolInsertQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolUpdateQueryProperties
{
  PROP_PROTOCOL_UPDATE_QUERY_0,
  PROP_PROTOCOL_UPDATE_QUERY_DATA_SOURCE,
  PROP_PROTOCOL_UPDATE_QUERY_FILTER,
  PROP_PROTOCOL_UPDATE_QUERY_ASSIGNMENTS
};

/* reads a protocol_update_query object */
static gint32
protocol_update_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolUpdateQuery * this_object = PROTOCOL_UPDATE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_source = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolAssignment * _elem16 = NULL;
              if ( _elem16 != NULL)
              {
                g_object_unref (_elem16);
              }
              _elem16 = g_object_new (TYPE_PROTOCOL_ASSIGNMENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem16), protocol, error)) < 0)
              {
                g_object_unref (_elem16);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->assignments, _elem16);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_assignments = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_update_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolUpdateQuery * this_object = PROTOCOL_UPDATE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolUpdateQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_source", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_source), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "assignments", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i17;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->assignments ? this_object->assignments->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i17 = 0; i17 < (this_object->assignments ? this_object->assignments->len : 0); i17++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->assignments, i17))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_update_query_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolUpdateQuery *self = PROTOCOL_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_UPDATE_QUERY_DATA_SOURCE:
      if (self->data_source != NULL)
        g_object_unref (self->data_source);
      self->data_source = g_value_dup_object (value);
      self->__isset_data_source = TRUE;
      break;

    case PROP_PROTOCOL_UPDATE_QUERY_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_PROTOCOL_UPDATE_QUERY_ASSIGNMENTS:
      if (self->assignments != NULL)
        g_ptr_array_unref (self->assignments);
      self->assignments = g_value_dup_boxed (value);
      self->__isset_assignments = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_update_query_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolUpdateQuery *self = PROTOCOL_UPDATE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_UPDATE_QUERY_DATA_SOURCE:
      g_value_set_object (value, self->data_source);
      break;

    case PROP_PROTOCOL_UPDATE_QUERY_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_PROTOCOL_UPDATE_QUERY_ASSIGNMENTS:
      g_value_set_boxed (value, self->assignments);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_update_query_instance_init (ProtocolUpdateQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->data_source = g_object_new (TYPE_PROTOCOL_DATA_SOURCE, NULL);
  object->__isset_data_source = FALSE;
  object->filter = g_object_new (TYPE_PROTOCOL_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->assignments = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_assignments = FALSE;
}

static void 
protocol_update_query_finalize (GObject *object)
{
  ProtocolUpdateQuery *tobject = PROTOCOL_UPDATE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data_source != NULL)
  {
    g_object_unref(tobject->data_source);
    tobject->data_source = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
  if (tobject->assignments != NULL)
  {
    g_ptr_array_unref (tobject->assignments);
    tobject->assignments = NULL;
  }
}

static void
protocol_update_query_class_init (ProtocolUpdateQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_update_query_read;
  struct_class->write = protocol_update_query_write;

  gobject_class->finalize = protocol_update_query_finalize;
  gobject_class->get_property = protocol_update_query_get_property;
  gobject_class->set_property = protocol_update_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_UPDATE_QUERY_DATA_SOURCE,
     g_param_spec_object ("data_source",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DATA_SOURCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_UPDATE_QUERY_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_UPDATE_QUERY_ASSIGNMENTS,
     g_param_spec_boxed ("assignments",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_update_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolUpdateQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_update_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolUpdateQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_update_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolUpdateQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolCreateTableQueryProperties
{
  PROP_PROTOCOL_CREATE_TABLE_QUERY_0,
  PROP_PROTOCOL_CREATE_TABLE_QUERY_TABLE_NAME,
  PROP_PROTOCOL_CREATE_TABLE_QUERY_DEFS
};

/* reads a protocol_create_table_query object */
static gint32
protocol_create_table_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolCreateTableQuery * this_object = PROTOCOL_CREATE_TABLE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolColumnDef * _elem18 = NULL;
              if ( _elem18 != NULL)
              {
                g_object_unref (_elem18);
              }
              _elem18 = g_object_new (TYPE_PROTOCOL_COLUMN_DEF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem18), protocol, error)) < 0)
              {
                g_object_unref (_elem18);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->defs, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_defs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_create_table_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolCreateTableQuery * this_object = PROTOCOL_CREATE_TABLE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolCreateTableQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "defs", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i19;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->defs ? this_object->defs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i19 = 0; i19 < (this_object->defs ? this_object->defs->len : 0); i19++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->defs, i19))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_create_table_query_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolCreateTableQuery *self = PROTOCOL_CREATE_TABLE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CREATE_TABLE_QUERY_TABLE_NAME:
      if (self->table_name != NULL)
        g_object_unref (self->table_name);
      self->table_name = g_value_dup_object (value);
      self->__isset_table_name = TRUE;
      break;

    case PROP_PROTOCOL_CREATE_TABLE_QUERY_DEFS:
      if (self->defs != NULL)
        g_ptr_array_unref (self->defs);
      self->defs = g_value_dup_boxed (value);
      self->__isset_defs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_create_table_query_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolCreateTableQuery *self = PROTOCOL_CREATE_TABLE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_CREATE_TABLE_QUERY_TABLE_NAME:
      g_value_set_object (value, self->table_name);
      break;

    case PROP_PROTOCOL_CREATE_TABLE_QUERY_DEFS:
      g_value_set_boxed (value, self->defs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_create_table_query_instance_init (ProtocolCreateTableQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_table_name = FALSE;
  object->defs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_defs = FALSE;
}

static void 
protocol_create_table_query_finalize (GObject *object)
{
  ProtocolCreateTableQuery *tobject = PROTOCOL_CREATE_TABLE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_object_unref(tobject->table_name);
    tobject->table_name = NULL;
  }
  if (tobject->defs != NULL)
  {
    g_ptr_array_unref (tobject->defs);
    tobject->defs = NULL;
  }
}

static void
protocol_create_table_query_class_init (ProtocolCreateTableQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_create_table_query_read;
  struct_class->write = protocol_create_table_query_write;

  gobject_class->finalize = protocol_create_table_query_finalize;
  gobject_class->get_property = protocol_create_table_query_get_property;
  gobject_class->set_property = protocol_create_table_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CREATE_TABLE_QUERY_TABLE_NAME,
     g_param_spec_object ("table_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_CREATE_TABLE_QUERY_DEFS,
     g_param_spec_boxed ("defs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
protocol_create_table_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolCreateTableQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_create_table_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolCreateTableQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_create_table_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolCreateTableQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolDeleteTableQueryProperties
{
  PROP_PROTOCOL_DELETE_TABLE_QUERY_0,
  PROP_PROTOCOL_DELETE_TABLE_QUERY_TABLE_NAME
};

/* reads a protocol_delete_table_query object */
static gint32
protocol_delete_table_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolDeleteTableQuery * this_object = PROTOCOL_DELETE_TABLE_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_delete_table_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolDeleteTableQuery * this_object = PROTOCOL_DELETE_TABLE_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolDeleteTableQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->table_name), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_delete_table_query_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolDeleteTableQuery *self = PROTOCOL_DELETE_TABLE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DELETE_TABLE_QUERY_TABLE_NAME:
      if (self->table_name != NULL)
        g_object_unref (self->table_name);
      self->table_name = g_value_dup_object (value);
      self->__isset_table_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_delete_table_query_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ProtocolDeleteTableQuery *self = PROTOCOL_DELETE_TABLE_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_DELETE_TABLE_QUERY_TABLE_NAME:
      g_value_set_object (value, self->table_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_delete_table_query_instance_init (ProtocolDeleteTableQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = g_object_new (TYPE_PROTOCOL_VARIABLE, NULL);
  object->__isset_table_name = FALSE;
}

static void 
protocol_delete_table_query_finalize (GObject *object)
{
  ProtocolDeleteTableQuery *tobject = PROTOCOL_DELETE_TABLE_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_object_unref(tobject->table_name);
    tobject->table_name = NULL;
  }
}

static void
protocol_delete_table_query_class_init (ProtocolDeleteTableQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_delete_table_query_read;
  struct_class->write = protocol_delete_table_query_write;

  gobject_class->finalize = protocol_delete_table_query_finalize;
  gobject_class->get_property = protocol_delete_table_query_get_property;
  gobject_class->set_property = protocol_delete_table_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_DELETE_TABLE_QUERY_TABLE_NAME,
     g_param_spec_object ("table_name",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_VARIABLE,
                         G_PARAM_READWRITE));
}

GType
protocol_delete_table_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolDeleteTableQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_delete_table_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolDeleteTableQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_delete_table_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolDeleteTableQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolQueryUnionProperties
{
  PROP_PROTOCOL_QUERY_UNION_0,
  PROP_PROTOCOL_QUERY_UNION_SELECT,
  PROP_PROTOCOL_QUERY_UNION_DELETE,
  PROP_PROTOCOL_QUERY_UNION_INSERT,
  PROP_PROTOCOL_QUERY_UNION_UPDATE,
  PROP_PROTOCOL_QUERY_UNION_CREATE_TABLE,
  PROP_PROTOCOL_QUERY_UNION_DELETE_TABLE
};

/* reads a protocol_query_union object */
static gint32
protocol_query_union_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolQueryUnion * this_object = PROTOCOL_QUERY_UNION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_select = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->delete), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_delete = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_insert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->create_table), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_create_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->delete_table), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_delete_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_query_union_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolQueryUnion * this_object = PROTOCOL_QUERY_UNION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolQueryUnion", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_select == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "select", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_delete == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "delete", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->delete), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_insert == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "insert", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_create_table == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "create_table", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->create_table), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_delete_table == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "delete_table", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->delete_table), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_query_union_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ProtocolQueryUnion *self = PROTOCOL_QUERY_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_UNION_SELECT:
      if (self->select != NULL)
        g_object_unref (self->select);
      self->select = g_value_dup_object (value);
      self->__isset_select = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_UNION_DELETE:
      if (self->delete != NULL)
        g_object_unref (self->delete);
      self->delete = g_value_dup_object (value);
      self->__isset_delete = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_UNION_INSERT:
      if (self->insert != NULL)
        g_object_unref (self->insert);
      self->insert = g_value_dup_object (value);
      self->__isset_insert = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_UNION_UPDATE:
      if (self->update != NULL)
        g_object_unref (self->update);
      self->update = g_value_dup_object (value);
      self->__isset_update = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_UNION_CREATE_TABLE:
      if (self->create_table != NULL)
        g_object_unref (self->create_table);
      self->create_table = g_value_dup_object (value);
      self->__isset_create_table = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_UNION_DELETE_TABLE:
      if (self->delete_table != NULL)
        g_object_unref (self->delete_table);
      self->delete_table = g_value_dup_object (value);
      self->__isset_delete_table = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_query_union_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ProtocolQueryUnion *self = PROTOCOL_QUERY_UNION (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_UNION_SELECT:
      g_value_set_object (value, self->select);
      break;

    case PROP_PROTOCOL_QUERY_UNION_DELETE:
      g_value_set_object (value, self->delete);
      break;

    case PROP_PROTOCOL_QUERY_UNION_INSERT:
      g_value_set_object (value, self->insert);
      break;

    case PROP_PROTOCOL_QUERY_UNION_UPDATE:
      g_value_set_object (value, self->update);
      break;

    case PROP_PROTOCOL_QUERY_UNION_CREATE_TABLE:
      g_value_set_object (value, self->create_table);
      break;

    case PROP_PROTOCOL_QUERY_UNION_DELETE_TABLE:
      g_value_set_object (value, self->delete_table);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_query_union_instance_init (ProtocolQueryUnion * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->select = g_object_new (TYPE_PROTOCOL_SELECT_QUERY, NULL);
  object->__isset_select = FALSE;
  object->delete = g_object_new (TYPE_PROTOCOL_DELETE_QUERY, NULL);
  object->__isset_delete = FALSE;
  object->insert = g_object_new (TYPE_PROTOCOL_INSERT_QUERY, NULL);
  object->__isset_insert = FALSE;
  object->update = g_object_new (TYPE_PROTOCOL_UPDATE_QUERY, NULL);
  object->__isset_update = FALSE;
  object->create_table = g_object_new (TYPE_PROTOCOL_CREATE_TABLE_QUERY, NULL);
  object->__isset_create_table = FALSE;
  object->delete_table = g_object_new (TYPE_PROTOCOL_DELETE_TABLE_QUERY, NULL);
  object->__isset_delete_table = FALSE;
}

static void 
protocol_query_union_finalize (GObject *object)
{
  ProtocolQueryUnion *tobject = PROTOCOL_QUERY_UNION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->select != NULL)
  {
    g_object_unref(tobject->select);
    tobject->select = NULL;
  }
  if (tobject->delete != NULL)
  {
    g_object_unref(tobject->delete);
    tobject->delete = NULL;
  }
  if (tobject->insert != NULL)
  {
    g_object_unref(tobject->insert);
    tobject->insert = NULL;
  }
  if (tobject->update != NULL)
  {
    g_object_unref(tobject->update);
    tobject->update = NULL;
  }
  if (tobject->create_table != NULL)
  {
    g_object_unref(tobject->create_table);
    tobject->create_table = NULL;
  }
  if (tobject->delete_table != NULL)
  {
    g_object_unref(tobject->delete_table);
    tobject->delete_table = NULL;
  }
}

static void
protocol_query_union_class_init (ProtocolQueryUnionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_query_union_read;
  struct_class->write = protocol_query_union_write;

  gobject_class->finalize = protocol_query_union_finalize;
  gobject_class->get_property = protocol_query_union_get_property;
  gobject_class->set_property = protocol_query_union_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_SELECT,
     g_param_spec_object ("select",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_SELECT_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_DELETE,
     g_param_spec_object ("delete",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DELETE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_INSERT,
     g_param_spec_object ("insert",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_INSERT_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_UPDATE,
     g_param_spec_object ("update",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_UPDATE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_CREATE_TABLE,
     g_param_spec_object ("create_table",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_CREATE_TABLE_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_UNION_DELETE_TABLE,
     g_param_spec_object ("delete_table",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_DELETE_TABLE_QUERY,
                         G_PARAM_READWRITE));
}

GType
protocol_query_union_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolQueryUnionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_query_union_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolQueryUnion),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_query_union_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolQueryUnionType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolQueryProperties
{
  PROP_PROTOCOL_QUERY_0,
  PROP_PROTOCOL_QUERY_TYPE,
  PROP_PROTOCOL_QUERY_QUERY
};

/* reads a protocol_query object */
static gint32
protocol_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolQuery * this_object = PROTOCOL_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast20;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast20, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolQueryType)ecast20;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolQuery * this_object = PROTOCOL_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolQuery", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_query_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  ProtocolQuery *self = PROTOCOL_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_query_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  ProtocolQuery *self = PROTOCOL_QUERY (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_QUERY_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_query_instance_init (ProtocolQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->query = g_object_new (TYPE_PROTOCOL_QUERY_UNION, NULL);
  object->__isset_query = FALSE;
}

static void 
protocol_query_finalize (GObject *object)
{
  ProtocolQuery *tobject = PROTOCOL_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
protocol_query_class_init (ProtocolQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_query_read;
  struct_class->write = protocol_query_write;

  gobject_class->finalize = protocol_query_finalize;
  gobject_class->get_property = protocol_query_get_property;
  gobject_class->set_property = protocol_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       6,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_QUERY_UNION,
                         G_PARAM_READWRITE));
}

GType
protocol_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _SelectQueryResultProperties
{
  PROP_SELECT_QUERY_RESULT_0,
  PROP_SELECT_QUERY_RESULT_DEFS,
  PROP_SELECT_QUERY_RESULT_COUNT,
  PROP_SELECT_QUERY_RESULT_DATA
};

/* reads a select_query_result object */
static gint32
select_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SelectQueryResult * this_object = SELECT_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolColumnDef * _elem21 = NULL;
              if ( _elem21 != NULL)
              {
                g_object_unref (_elem21);
              }
              _elem21 = g_object_new (TYPE_PROTOCOL_COLUMN_DEF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem21), protocol, error)) < 0)
              {
                g_object_unref (_elem21);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->defs, _elem21);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_defs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem22 = g_ptr_array_new_with_free_func (g_object_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  ProtocolConstant * _elem23 = NULL;
                  if ( _elem23 != NULL)
                  {
                    g_object_unref (_elem23);
                  }
                  _elem23 = g_object_new (TYPE_PROTOCOL_CONSTANT, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem23), protocol, error)) < 0)
                  {
                    g_object_unref (_elem23);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (_elem22, _elem23);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->data, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
select_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SelectQueryResult * this_object = SELECT_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SelectQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "defs", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i24;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->defs ? this_object->defs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i24 = 0; i24 < (this_object->defs ? this_object->defs->len : 0); i24++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->defs, i24))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i25;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) (this_object->data ? this_object->data->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i25 = 0; i25 < (this_object->data ? this_object->data->len : 0); i25++)
    {
      {
        guint i26;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i25)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i25))->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i26 = 0; i26 < (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i25)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i25))->len : 0); i26++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->data, i25)), i26))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
select_query_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  SelectQueryResult *self = SELECT_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SELECT_QUERY_RESULT_DEFS:
      if (self->defs != NULL)
        g_ptr_array_unref (self->defs);
      self->defs = g_value_dup_boxed (value);
      self->__isset_defs = TRUE;
      break;

    case PROP_SELECT_QUERY_RESULT_COUNT:
      self->count = g_value_get_int (value);
      self->__isset_count = TRUE;
      break;

    case PROP_SELECT_QUERY_RESULT_DATA:
      if (self->data != NULL)
        g_ptr_array_unref (self->data);
      self->data = g_value_dup_boxed (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
select_query_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  SelectQueryResult *self = SELECT_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SELECT_QUERY_RESULT_DEFS:
      g_value_set_boxed (value, self->defs);
      break;

    case PROP_SELECT_QUERY_RESULT_COUNT:
      g_value_set_int (value, self->count);
      break;

    case PROP_SELECT_QUERY_RESULT_DATA:
      g_value_set_boxed (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
select_query_result_instance_init (SelectQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->defs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_defs = FALSE;
  object->count = 0;
  object->__isset_count = FALSE;
  object->data = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_data = FALSE;
}

static void 
select_query_result_finalize (GObject *object)
{
  SelectQueryResult *tobject = SELECT_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->defs != NULL)
  {
    g_ptr_array_unref (tobject->defs);
    tobject->defs = NULL;
  }
  if (tobject->data != NULL)
  {
    g_ptr_array_unref (tobject->data);
    tobject->data = NULL;
  }
}

static void
select_query_result_class_init (SelectQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = select_query_result_read;
  struct_class->write = select_query_result_write;

  gobject_class->finalize = select_query_result_finalize;
  gobject_class->get_property = select_query_result_get_property;
  gobject_class->set_property = select_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_QUERY_RESULT_DEFS,
     g_param_spec_boxed ("defs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_QUERY_RESULT_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_QUERY_RESULT_DATA,
     g_param_spec_boxed ("data",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
select_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SelectQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) select_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SelectQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) select_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SelectQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _InsertQueryResultProperties
{
  PROP_INSERT_QUERY_RESULT_0,
  PROP_INSERT_QUERY_RESULT_COUNT
};

/* reads a insert_query_result object */
static gint32
insert_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InsertQueryResult * this_object = INSERT_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
insert_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  InsertQueryResult * this_object = INSERT_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InsertQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
insert_query_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  InsertQueryResult *self = INSERT_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_INSERT_QUERY_RESULT_COUNT:
      self->count = g_value_get_int (value);
      self->__isset_count = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
insert_query_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  InsertQueryResult *self = INSERT_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_INSERT_QUERY_RESULT_COUNT:
      g_value_set_int (value, self->count);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
insert_query_result_instance_init (InsertQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
  object->__isset_count = FALSE;
}

static void 
insert_query_result_finalize (GObject *object)
{
  InsertQueryResult *tobject = INSERT_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
insert_query_result_class_init (InsertQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = insert_query_result_read;
  struct_class->write = insert_query_result_write;

  gobject_class->finalize = insert_query_result_finalize;
  gobject_class->get_property = insert_query_result_get_property;
  gobject_class->set_property = insert_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INSERT_QUERY_RESULT_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
insert_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (InsertQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) insert_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (InsertQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) insert_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "InsertQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _DeleteQueryResultProperties
{
  PROP_DELETE_QUERY_RESULT_0,
  PROP_DELETE_QUERY_RESULT_COUNT
};

/* reads a delete_query_result object */
static gint32
delete_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeleteQueryResult * this_object = DELETE_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
delete_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeleteQueryResult * this_object = DELETE_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeleteQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
delete_query_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  DeleteQueryResult *self = DELETE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_DELETE_QUERY_RESULT_COUNT:
      self->count = g_value_get_int (value);
      self->__isset_count = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
delete_query_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  DeleteQueryResult *self = DELETE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_DELETE_QUERY_RESULT_COUNT:
      g_value_set_int (value, self->count);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
delete_query_result_instance_init (DeleteQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
  object->__isset_count = FALSE;
}

static void 
delete_query_result_finalize (GObject *object)
{
  DeleteQueryResult *tobject = DELETE_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
delete_query_result_class_init (DeleteQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = delete_query_result_read;
  struct_class->write = delete_query_result_write;

  gobject_class->finalize = delete_query_result_finalize;
  gobject_class->get_property = delete_query_result_get_property;
  gobject_class->set_property = delete_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_QUERY_RESULT_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
delete_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeleteQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) delete_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeleteQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) delete_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeleteQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UpdateQueryResultProperties
{
  PROP_UPDATE_QUERY_RESULT_0,
  PROP_UPDATE_QUERY_RESULT_COUNT
};

/* reads a update_query_result object */
static gint32
update_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UpdateQueryResult * this_object = UPDATE_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
update_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UpdateQueryResult * this_object = UPDATE_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UpdateQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
update_query_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  UpdateQueryResult *self = UPDATE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_UPDATE_QUERY_RESULT_COUNT:
      self->count = g_value_get_int (value);
      self->__isset_count = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
update_query_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  UpdateQueryResult *self = UPDATE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_UPDATE_QUERY_RESULT_COUNT:
      g_value_set_int (value, self->count);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
update_query_result_instance_init (UpdateQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
  object->__isset_count = FALSE;
}

static void 
update_query_result_finalize (GObject *object)
{
  UpdateQueryResult *tobject = UPDATE_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
update_query_result_class_init (UpdateQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = update_query_result_read;
  struct_class->write = update_query_result_write;

  gobject_class->finalize = update_query_result_finalize;
  gobject_class->get_property = update_query_result_get_property;
  gobject_class->set_property = update_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_QUERY_RESULT_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
update_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UpdateQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) update_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UpdateQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) update_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UpdateQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _CreateTableQueryResultProperties
{
  PROP_CREATE_TABLE_QUERY_RESULT_0,
  PROP_CREATE_TABLE_QUERY_RESULT_DEFS
};

/* reads a create_table_query_result object */
static gint32
create_table_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CreateTableQueryResult * this_object = CREATE_TABLE_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ProtocolColumnDef * _elem27 = NULL;
              if ( _elem27 != NULL)
              {
                g_object_unref (_elem27);
              }
              _elem27 = g_object_new (TYPE_PROTOCOL_COLUMN_DEF, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem27), protocol, error)) < 0)
              {
                g_object_unref (_elem27);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->defs, _elem27);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_defs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
create_table_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CreateTableQueryResult * this_object = CREATE_TABLE_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CreateTableQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "defs", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i28;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->defs ? this_object->defs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i28 = 0; i28 < (this_object->defs ? this_object->defs->len : 0); i28++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->defs, i28))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
create_table_query_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  CreateTableQueryResult *self = CREATE_TABLE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_CREATE_TABLE_QUERY_RESULT_DEFS:
      if (self->defs != NULL)
        g_ptr_array_unref (self->defs);
      self->defs = g_value_dup_boxed (value);
      self->__isset_defs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
create_table_query_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  CreateTableQueryResult *self = CREATE_TABLE_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_CREATE_TABLE_QUERY_RESULT_DEFS:
      g_value_set_boxed (value, self->defs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
create_table_query_result_instance_init (CreateTableQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->defs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_defs = FALSE;
}

static void 
create_table_query_result_finalize (GObject *object)
{
  CreateTableQueryResult *tobject = CREATE_TABLE_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->defs != NULL)
  {
    g_ptr_array_unref (tobject->defs);
    tobject->defs = NULL;
  }
}

static void
create_table_query_result_class_init (CreateTableQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = create_table_query_result_read;
  struct_class->write = create_table_query_result_write;

  gobject_class->finalize = create_table_query_result_finalize;
  gobject_class->get_property = create_table_query_result_get_property;
  gobject_class->set_property = create_table_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_TABLE_QUERY_RESULT_DEFS,
     g_param_spec_boxed ("defs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
create_table_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CreateTableQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) create_table_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CreateTableQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) create_table_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CreateTableQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a delete_table_query_result object */
static gint32
delete_table_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeleteTableQueryResult * this_object = DELETE_TABLE_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
delete_table_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeleteTableQueryResult * this_object = DELETE_TABLE_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeleteTableQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
delete_table_query_result_instance_init (DeleteTableQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
delete_table_query_result_finalize (GObject *object)
{
  DeleteTableQueryResult *tobject = DELETE_TABLE_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
delete_table_query_result_class_init (DeleteTableQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = delete_table_query_result_read;
  struct_class->write = delete_table_query_result_write;

  gobject_class->finalize = delete_table_query_result_finalize;
}

GType
delete_table_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeleteTableQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) delete_table_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeleteTableQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) delete_table_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeleteTableQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ProtocolQueryResultProperties
{
  PROP_PROTOCOL_QUERY_RESULT_0,
  PROP_PROTOCOL_QUERY_RESULT_CODE,
  PROP_PROTOCOL_QUERY_RESULT_TYPE,
  PROP_PROTOCOL_QUERY_RESULT_SELECT,
  PROP_PROTOCOL_QUERY_RESULT_INSERT,
  PROP_PROTOCOL_QUERY_RESULT_DELETE,
  PROP_PROTOCOL_QUERY_RESULT_UPDATE,
  PROP_PROTOCOL_QUERY_RESULT_CREATE_TABLE,
  PROP_PROTOCOL_QUERY_RESULT_DELETE_TABLE,
  PROP_PROTOCOL_QUERY_RESULT_ERROR_MESSAGE
};

/* reads a protocol_query_result object */
static gint32
protocol_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ProtocolQueryResult * this_object = PROTOCOL_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast29;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast29, error)) < 0)
            return -1;
          xfer += ret;
          this_object->code = (ProtocolQueryResultCode)ecast29;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast30;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast30, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ProtocolQueryType)ecast30;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_select = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_insert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->delete), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_delete = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->create_table), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_create_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->delete_table), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_delete_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->error_message != NULL)
          {
            g_free(this_object->error_message);
            this_object->error_message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->error_message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_error_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
protocol_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ProtocolQueryResult * this_object = PROTOCOL_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ProtocolQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "select", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "insert", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "delete", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->delete), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "update", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "create_table", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->create_table), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "delete_table", T_STRUCT, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->delete_table), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "error_message", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->error_message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
protocol_query_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolQueryResult *self = PROTOCOL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_RESULT_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_SELECT:
      if (self->select != NULL)
        g_object_unref (self->select);
      self->select = g_value_dup_object (value);
      self->__isset_select = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_INSERT:
      if (self->insert != NULL)
        g_object_unref (self->insert);
      self->insert = g_value_dup_object (value);
      self->__isset_insert = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_DELETE:
      if (self->delete != NULL)
        g_object_unref (self->delete);
      self->delete = g_value_dup_object (value);
      self->__isset_delete = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_UPDATE:
      if (self->update != NULL)
        g_object_unref (self->update);
      self->update = g_value_dup_object (value);
      self->__isset_update = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_CREATE_TABLE:
      if (self->create_table != NULL)
        g_object_unref (self->create_table);
      self->create_table = g_value_dup_object (value);
      self->__isset_create_table = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_DELETE_TABLE:
      if (self->delete_table != NULL)
        g_object_unref (self->delete_table);
      self->delete_table = g_value_dup_object (value);
      self->__isset_delete_table = TRUE;
      break;

    case PROP_PROTOCOL_QUERY_RESULT_ERROR_MESSAGE:
      if (self->error_message != NULL)
        g_free (self->error_message);
      self->error_message = g_value_dup_string (value);
      self->__isset_error_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
protocol_query_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ProtocolQueryResult *self = PROTOCOL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_PROTOCOL_QUERY_RESULT_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_SELECT:
      g_value_set_object (value, self->select);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_INSERT:
      g_value_set_object (value, self->insert);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_DELETE:
      g_value_set_object (value, self->delete);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_UPDATE:
      g_value_set_object (value, self->update);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_CREATE_TABLE:
      g_value_set_object (value, self->create_table);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_DELETE_TABLE:
      g_value_set_object (value, self->delete_table);
      break;

    case PROP_PROTOCOL_QUERY_RESULT_ERROR_MESSAGE:
      g_value_set_string (value, self->error_message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
protocol_query_result_instance_init (ProtocolQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_code = FALSE;
  object->__isset_type = FALSE;
  object->select = g_object_new (TYPE_SELECT_QUERY_RESULT, NULL);
  object->__isset_select = FALSE;
  object->insert = g_object_new (TYPE_INSERT_QUERY_RESULT, NULL);
  object->__isset_insert = FALSE;
  object->delete = g_object_new (TYPE_DELETE_QUERY_RESULT, NULL);
  object->__isset_delete = FALSE;
  object->update = g_object_new (TYPE_UPDATE_QUERY_RESULT, NULL);
  object->__isset_update = FALSE;
  object->create_table = g_object_new (TYPE_CREATE_TABLE_QUERY_RESULT, NULL);
  object->__isset_create_table = FALSE;
  object->delete_table = g_object_new (TYPE_DELETE_TABLE_QUERY_RESULT, NULL);
  object->__isset_delete_table = FALSE;
  object->error_message = NULL;
  object->__isset_error_message = FALSE;
}

static void 
protocol_query_result_finalize (GObject *object)
{
  ProtocolQueryResult *tobject = PROTOCOL_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->select != NULL)
  {
    g_object_unref(tobject->select);
    tobject->select = NULL;
  }
  if (tobject->insert != NULL)
  {
    g_object_unref(tobject->insert);
    tobject->insert = NULL;
  }
  if (tobject->delete != NULL)
  {
    g_object_unref(tobject->delete);
    tobject->delete = NULL;
  }
  if (tobject->update != NULL)
  {
    g_object_unref(tobject->update);
    tobject->update = NULL;
  }
  if (tobject->create_table != NULL)
  {
    g_object_unref(tobject->create_table);
    tobject->create_table = NULL;
  }
  if (tobject->delete_table != NULL)
  {
    g_object_unref(tobject->delete_table);
    tobject->delete_table = NULL;
  }
  if (tobject->error_message != NULL)
  {
    g_free(tobject->error_message);
    tobject->error_message = NULL;
  }
}

static void
protocol_query_result_class_init (ProtocolQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = protocol_query_result_read;
  struct_class->write = protocol_query_result_write;

  gobject_class->finalize = protocol_query_result_finalize;
  gobject_class->get_property = protocol_query_result_get_property;
  gobject_class->set_property = protocol_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       1,
                       6,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_SELECT,
     g_param_spec_object ("select",
                         NULL,
                         NULL,
                         TYPE_SELECT_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_INSERT,
     g_param_spec_object ("insert",
                         NULL,
                         NULL,
                         TYPE_INSERT_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_DELETE,
     g_param_spec_object ("delete",
                         NULL,
                         NULL,
                         TYPE_DELETE_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_UPDATE,
     g_param_spec_object ("update",
                         NULL,
                         NULL,
                         TYPE_UPDATE_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_CREATE_TABLE,
     g_param_spec_object ("create_table",
                         NULL,
                         NULL,
                         TYPE_CREATE_TABLE_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_DELETE_TABLE,
     g_param_spec_object ("delete_table",
                         NULL,
                         NULL,
                         TYPE_DELETE_TABLE_QUERY_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROTOCOL_QUERY_RESULT_ERROR_MESSAGE,
     g_param_spec_string ("error_message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
protocol_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ProtocolQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) protocol_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ProtocolQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) protocol_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ProtocolQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _QueryExecutorExecuteArgsProperties
{
  PROP_QUERY_EXECUTOR_EXECUTE_ARGS_0,
  PROP_QUERY_EXECUTOR_EXECUTE_ARGS_QUERY
};

/* reads a query_executor_execute_args object */
static gint32
query_executor_execute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  QueryExecutorExecuteArgs * this_object = QUERY_EXECUTOR_EXECUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_executor_execute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  QueryExecutorExecuteArgs * this_object = QUERY_EXECUTOR_EXECUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "QueryExecutorExecuteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_executor_execute_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  QueryExecutorExecuteArgs *self = QUERY_EXECUTOR_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_EXECUTOR_EXECUTE_ARGS_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_executor_execute_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  QueryExecutorExecuteArgs *self = QUERY_EXECUTOR_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_QUERY_EXECUTOR_EXECUTE_ARGS_QUERY:
      g_value_set_object (value, self->query);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_executor_execute_args_instance_init (QueryExecutorExecuteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->query = g_object_new (TYPE_PROTOCOL_QUERY, NULL);
  object->__isset_query = FALSE;
}

static void 
query_executor_execute_args_finalize (GObject *object)
{
  QueryExecutorExecuteArgs *tobject = QUERY_EXECUTOR_EXECUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
}

static void
query_executor_execute_args_class_init (QueryExecutorExecuteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_executor_execute_args_read;
  struct_class->write = query_executor_execute_args_write;

  gobject_class->finalize = query_executor_execute_args_finalize;
  gobject_class->get_property = query_executor_execute_args_get_property;
  gobject_class->set_property = query_executor_execute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_EXECUTOR_EXECUTE_ARGS_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_QUERY,
                         G_PARAM_READWRITE));
}

GType
query_executor_execute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (QueryExecutorExecuteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_executor_execute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (QueryExecutorExecuteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_executor_execute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "QueryExecutorExecuteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _QueryExecutorExecuteResultProperties
{
  PROP_QUERY_EXECUTOR_EXECUTE_RESULT_0,
  PROP_QUERY_EXECUTOR_EXECUTE_RESULT_SUCCESS
};

/* reads a query_executor_execute_result object */
static gint32
query_executor_execute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  QueryExecutorExecuteResult * this_object = QUERY_EXECUTOR_EXECUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
query_executor_execute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  QueryExecutorExecuteResult * this_object = QUERY_EXECUTOR_EXECUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "QueryExecutorExecuteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
query_executor_execute_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  QueryExecutorExecuteResult *self = QUERY_EXECUTOR_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_EXECUTOR_EXECUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
query_executor_execute_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  QueryExecutorExecuteResult *self = QUERY_EXECUTOR_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_QUERY_EXECUTOR_EXECUTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
query_executor_execute_result_instance_init (QueryExecutorExecuteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PROTOCOL_QUERY_RESULT, NULL);
  object->__isset_success = FALSE;
}

static void 
query_executor_execute_result_finalize (GObject *object)
{
  QueryExecutorExecuteResult *tobject = QUERY_EXECUTOR_EXECUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
query_executor_execute_result_class_init (QueryExecutorExecuteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = query_executor_execute_result_read;
  struct_class->write = query_executor_execute_result_write;

  gobject_class->finalize = query_executor_execute_result_finalize;
  gobject_class->get_property = query_executor_execute_result_get_property;
  gobject_class->set_property = query_executor_execute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_QUERY_EXECUTOR_EXECUTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PROTOCOL_QUERY_RESULT,
                         G_PARAM_READWRITE));
}

GType
query_executor_execute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (QueryExecutorExecuteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) query_executor_execute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (QueryExecutorExecuteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) query_executor_execute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "QueryExecutorExecuteResultType",
                                   &type_info, 0);
  }

  return type;
}

